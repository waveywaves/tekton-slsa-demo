apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: enhanced-build-sign
  namespace: default
  labels:
    slsa-demo: "true"
spec:
  params:
  - name: IMAGE_NAME
    description: Name of the image to build
    default: "ttl.sh/tekton-slsa-demo"
  - name: IMAGE_TAG
    description: Tag for the image
    default: "latest"
  - name: SOURCE_URL
    description: Git repository URL
    default: "https://github.com/waveywaves/tekton-slsa-demo"
  workspaces:
  - name: source
    description: Workspace containing the source code
  results:
  - name: IMAGE_URL
    description: URL of the built image with tag
  - name: IMAGE_DIGEST
    description: Digest of the built image  
  - name: ATTESTATION_URL
    description: URL where attestation will be stored
  steps:
  - name: fetch-source
    image: alpine/git:2.36.3
    workingDir: $(workspaces.source.path)
    script: |
      #!/bin/sh
      set -ex
      echo "=== Fetching Source Code ==="
      # Create our demo Go application structure
      echo "Creating demo Go application structure..."
      mkdir -p cmd
      cat > go.mod << 'GOMOD'
      module github.com/waveywaves/tekton-slsa-demo
      go 1.21
      GOMOD

      cat > cmd/main.go << 'MAIN'
      package main
      import (
          "fmt"
          "log"
          "net/http"
          "time"
      )
      func main() {
          http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
              fmt.Fprintf(w, "Hello from SLSA-Signed Tekton Demo! Built at: %s", time.Now().Format(time.RFC3339))
          })
          http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
              w.Header().Set("Content-Type", "application/json")
              fmt.Fprintf(w, `{"status":"healthy","signing":"x509-key-based","timestamp":"%s"}`, time.Now().Format(time.RFC3339))
          })
          log.Println("SLSA-signed application starting on :8080")
          log.Fatal(http.ListenAndServe(":8080", nil))
      }
      MAIN

      cat > Dockerfile << 'DOCKERFILE'
      FROM golang:1.21-alpine AS builder
      WORKDIR /app
      COPY go.mod ./
      RUN go mod download
      COPY cmd/ ./cmd/
      RUN CGO_ENABLED=0 go build -o app ./cmd/main.go
      FROM alpine:3.18
      RUN adduser -D appuser
      COPY --from=builder /app/app .
      USER appuser
      EXPOSE 8080
      HEALTHCHECK --interval=30s CMD wget -q --spider http://localhost:8080/health || exit 1
      CMD ["./app"]
      DOCKERFILE
      echo "Source code ready for build"
  - name: build-image
    image: gcr.io/kaniko-project/executor:v1.15.0-debug
    workingDir: $(workspaces.source.path)
    env:
    - name: DOCKER_CONFIG
      value: /kaniko/.docker
    script: |
      #!/busybox/sh
      set -ex
      
      echo "=== Building Container Image ==="
      IMAGE_URL="$(params.IMAGE_NAME):$(params.IMAGE_TAG)"
      echo "Building image: $IMAGE_URL"
      
      # Build with Kaniko for ttl.sh registry
      echo "Starting Kaniko build and push to ttl.sh..."
      echo "Building image: $IMAGE_URL"
      
      # Build and push with Kaniko to ttl.sh (external registry)
      /kaniko/executor \
        --dockerfile=Dockerfile \
        --destination=$IMAGE_URL \
        --context=. \
        --digest-file=/tmp/digest \
        --image-name-with-digest-file=/tmp/image-digest \
        --verbosity=info
        
      # Verify the build succeeded
      if [ ! -f /tmp/digest ]; then
        echo "ERROR: Kaniko build failed - no digest file created"
        exit 1
      fi
      
      IMAGE_DIGEST=$(cat /tmp/digest)
      echo "âœ… Build successful with digest: $IMAGE_DIGEST"
      
      echo "=== Build Results ==="
      echo "Image URL: $IMAGE_URL"
      echo "Image Digest: $IMAGE_DIGEST"
      
      # Write results that Chains will capture and sign
      echo -n "$IMAGE_URL" > $(results.IMAGE_URL.path)
      echo -n "$IMAGE_DIGEST" > $(results.IMAGE_DIGEST.path)  
      echo -n "$IMAGE_URL@$IMAGE_DIGEST" > $(results.ATTESTATION_URL.path)
      
      echo "=== Build completed successfully! ==="